package genopenapi3

import (
	"bytes"
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/go-test/deep"
	"go.aporeto.io/regolithe/spec"
	"gopkg.in/yaml.v2"
)

func TestConverter_Do(t *testing.T) {

	cases := map[string]struct {
		inSpec              string
		inSkipPrivateModels bool
		outDoc              string
	}{
		"test": {
			inSpec: `
        # Model
        model:
          rest_name: log
          resource_name: logs
          entity_name: Log
          package: highwind
          group: integration/app
          description: Retrieves the logs of a deployed application.

        # Attributes
        attributes:
          v1:
          - name: data
            description: Contains all log data.
            type: external
            exposed: true
            subtype: map[string]string
            read_only: true
            autogenerated: true
      `,
			outDoc: "{}",
		},
	}

	rootTmpDir, err := os.MkdirTemp("", t.Name()+"_*")
	if err != nil {
		t.Fatalf("error creating temporary directory for test function: %v", err)
	}
	defer os.RemoveAll(rootTmpDir)

	for name, c := range cases {
		t.Run(name, func(t *testing.T) {

			// this is to ensure that each test case is isolated
			specDir, err := os.MkdirTemp(rootTmpDir, name)
			if err != nil {
				t.Fatalf("error creating temporary directory for test case: %v", err)
			}

			// this is needed because the spec filename has to match the rest_name of the spec model
			var inSpecDeserialized struct {
				Model struct {
					RESTName string `yaml:"rest_name"`
				}
			}
			if err := yaml.Unmarshal([]byte(c.inSpec), &inSpecDeserialized); err != nil {
				t.Fatalf("error unmarshaling test spec data to read key 'rest_name': %v", err)
			}

			for filename, content := range map[string]string{
				// these files are needed by regolithe to parse the raw model from the test case
				"regolithe.ini": regolitheINI,
				"_type.mapping": typemapping,
				// this is what will be parsed by regolithe
				inSpecDeserialized.Model.RESTName + ".spec": c.inSpec,
			} {
				filename = filepath.Join(specDir, filename)
				if err := os.WriteFile(filename, []byte(content), os.ModePerm); err != nil {
					t.Fatalf("error writing temporary file '%s': %v", filename, err)
				}
			}

			spec, err := spec.LoadSpecificationSet(specDir, nil, nil, "openapi3")
			if err != nil {
				t.Fatalf("error parsing spec set from test data: %v", err)
			}

			converter := newConverter(spec, c.inSkipPrivateModels)
			output := new(bytes.Buffer)
			if err := converter.Do(output); err != nil {
				t.Fatalf("error converting spec to openapi3: %v", err)
			}

			expected := make(map[string]interface{})
			if err := json.Unmarshal([]byte(c.outDoc), &expected); err != nil {
				t.Fatalf("invalid expected output data in test case: malformed json content: %v", err)
			}
			actual := make(map[string]interface{})
			if err := json.Unmarshal(output.Bytes(), &actual); err != nil {
				t.Fatalf("invalid actual output data: malformed json content: %v", err)
			}
			if diff := deep.Equal(expected, actual); diff != nil {
				t.Fatal("actual output != expected output\n", strings.Join(diff, "\n"))
			}
		})
	}
}
