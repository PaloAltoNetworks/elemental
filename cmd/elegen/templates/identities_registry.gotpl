package {{ .Set.Configuration.Name }}

import "github.com/aporeto-inc/elemental"

var (
    identityNamesMap = map[string]elemental.Identity {
        {{- range .Set.Specifications }}
        {{ if shouldRegisterSpecification . $.PublicMode }}
        {{- $entityName := .Model.EntityName -}}
        "{{.Model.RestName}}": {{ $entityName }}Identity,
        {{- end }}
        {{- end }}
    }

    identitycategoriesMap = map[string]elemental.Identity {
        {{- range .Set.Specifications }}
        {{ if shouldRegisterSpecification . $.PublicMode }}
        {{- $entityName := .Model.EntityName -}}
        "{{.Model.ResourceName}}": {{ $entityName }}Identity,
        {{- end }}
        {{- end }}
    }

    aliasesMap = map[string]elemental.Identity {
        {{- range .Set.Specifications }}
        {{- if shouldRegisterSpecification . $.PublicMode }}
        {{- $entityName := .Model.EntityName -}}
        {{ range $i, $alias := .Model.Aliases }}
        "{{ $alias }}": {{ $entityName }}Identity,
        {{- end }}
        {{- end }}
        {{- end }}
    }
)

// ModelVersion returns the current version of the model.
func ModelVersion() float64 { return {{ .Set.APIInfo.Version }} }

type identifiableFactory struct{}

func(f identifiableFactory) IdentityFromName(name string) elemental.Identity {

    return identityNamesMap[name]
}

func(f identifiableFactory) IdentityFromCategory(category string) elemental.Identity {

    return identitycategoriesMap[category]
}

func(f identifiableFactory) IdentityFromAlias(alias string) elemental.Identity {

    return aliasesMap[alias]
}

func(f identifiableFactory) IdentityFromAny(any string) (i elemental.Identity) {

    if i = f.IdentityFromName(any); !i.IsEmpty() {
        return i
    }

    if i = f.IdentityFromCategory(any); !i.IsEmpty() {
        return i
    }

    return f.IdentityFromAlias(any)
}

func(f identifiableFactory) Identifiable(identity elemental.Identity) elemental.Identifiable {

    switch identity {
    {{ range .Set.Specifications }}
    {{- if shouldRegisterSpecification . $.PublicMode }}
    case {{ .Model.EntityName }}Identity:
        return New{{ .Model.EntityName }}()
    {{- end }}
    {{- end }}
    default:
        return nil
    }
}

func(f identifiableFactory) IdentifiableFromString(any string) elemental.Identifiable {

    return f.Identifiable(f.IdentityFromAny(any))
}

func(f identifiableFactory) ContentIdentifiable(identity elemental.Identity) elemental.ContentIdentifiable {

    switch identity {
    {{ range .Set.Specifications }}
    {{- if not .Model.IsRoot }}
    {{- if shouldRegisterSpecification . $.PublicMode }}
    case {{ .Model.EntityName }}Identity:
        return &{{ .Model.EntityNamePlural }}List{}
    {{- end }}
    {{- end }}
    {{- end }}
    default:
        return nil
    }
}

func(f identifiableFactory) ContentIdentifiableFromString(any string) elemental.ContentIdentifiable {

    return f.ContentIdentifiable(f.IdentityFromAny(any))
}

var ifactory = identifiableFactory{}

// Factory returns the model elemental.IdentifiableFactory.
func Factory() elemental.IdentifiableFactory { return ifactory }


// AllIdentities returns all existing identities.
func AllIdentities() []elemental.Identity {

    return []elemental.Identity{
        {{- range .Set.Specifications }}
        {{- if shouldRegisterSpecification . $.PublicMode }}
        {{ .Model.EntityName }}Identity,
        {{- end }}
        {{- end }}
    }
}

// AliasesForIdentity returns all the aliases for the given identity.
func AliasesForIdentity(identity elemental.Identity) []string {

    switch identity {
    {{- range .Set.Specifications }}
    {{- if shouldRegisterSpecification . $.PublicMode }}
    case {{ .Model.EntityName }}Identity:
        return []string{ {{ range $i, $alias := .Model.Aliases }}
        "{{ $alias }}",
        {{- end }}
        }
    {{- end }}
    {{- end }}
    }

    return nil
}
