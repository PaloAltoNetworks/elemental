package {{ .Set.Configuration.Name }}

import (
    "fmt"
    "go.aporeto.io/elemental"
    "github.com/globalsign/mgo/bson"
    "github.com/mitchellh/copystructure"
    {{- range .Spec.TypeProviders }}
    "{{ . }}"
    {{- end -}}
    {{- range .Spec.ValidationProviders }}
    "{{ . }}"
    {{- end }}
)

{{ $latestVersion := .Spec.LatestAttributesVersion }}

{{ range $i, $enum := buildEnums .Spec $latestVersion }}
// {{ $enum.Type }} represents the possible values for attribute "{{ $enum.AttributeName }}".
type {{ $enum.Type }} string

const (
    {{- range $name, $value := $enum.Values }}
    // {{ $name }} represents the value {{ $value }}.
    {{ $name }} {{ $enum.Type }} = "{{ $value }}"
    {{ end }}
)
{{ end }}

{{- if not .Spec.Model.Detached }}
// {{ .Spec.Model.EntityName }}Identity represents the Identity of the object.
var {{ .Spec.Model.EntityName }}Identity = elemental.Identity {
    Name:     "{{ .Spec.Model.RestName}}",
    Category: "{{ .Spec.Model.ResourceName }}",
    Package:  "{{ .Spec.Model.Package}}",
    Private:  {{ .Spec.Model.Private}},
}
{{ end }}

{{- if not .Spec.Model.Detached }}
{{ if not .Spec.Model.IsRoot }}
// {{ .Spec.Model.EntityNamePlural }}List represents a list of {{ .Spec.Model.EntityNamePlural }}
type {{ .Spec.Model.EntityNamePlural }}List []*{{ .Spec.Model.EntityName}}

// Identity returns the identity of the objects in the list.
func (o {{ .Spec.Model.EntityNamePlural }}List) Identity() elemental.Identity {

    return {{ .Spec.Model.EntityName}}Identity
}

// Copy returns a pointer to a copy the {{ .Spec.Model.EntityNamePlural }}List.
func (o {{ .Spec.Model.EntityNamePlural }}List) Copy() elemental.Identifiables {

    copy := append({{ .Spec.Model.EntityNamePlural }}List{}, o...)
    return &copy
}

// Append appends the objects to the a new copy of the {{ .Spec.Model.EntityNamePlural }}List.
func (o {{ .Spec.Model.EntityNamePlural }}List) Append(objects ...elemental.Identifiable) elemental.Identifiables {

    out := append({{ .Spec.Model.EntityNamePlural }}List{}, o...)
    for _, obj := range objects {
        out = append(out, obj.(*{{ .Spec.Model.EntityName}}))
    }

    return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o {{ .Spec.Model.EntityNamePlural }}List) List() elemental.IdentifiablesList {

    out := make(elemental.IdentifiablesList, len(o))
    for i := 0; i < len(o); i++ {
        out[i] = o[i]
    }

    return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o {{ .Spec.Model.EntityNamePlural }}List) DefaultOrder() []string {

    return []string{
        {{ range .Spec.DefaultOrder -}}
        "{{ . }}",
        {{ end }}
    }
}

// ToSparse returns the {{ .Spec.Model.EntityNamePlural }}List converted to Sparse{{ .Spec.Model.EntityNamePlural }}List.
// Objects in the list will only contain the given fields. No field means entire field set.
func (o {{ .Spec.Model.EntityNamePlural }}List) ToSparse(fields ...string) elemental.Identifiables {

    out := make(Sparse{{ .Spec.Model.EntityNamePlural }}List, len(o))
    for i := 0; i < len(o); i++ {
        out[i] = o[i].ToSparse(fields...).(*Sparse{{ .Spec.Model.EntityName }})
    }

    return out
}

// Version returns the version of the content.
func (o {{ .Spec.Model.EntityNamePlural }}List) Version() int {

    return {{ .Set.APIInfo.Version }}
}

{{ end }}
{{- end }}

{{- $isEncryptable := false }}
// {{ .Spec.Model.EntityName }} represents the model of a {{ .Spec.Model.RestName }}
type {{ .Spec.Model.EntityName }} struct {
{{- range .Spec.Attributes $latestVersion -}}{{- if .Encrypted }}{{- $isEncryptable = true }}{{- end }}
{{ attrToField $.Set false . }}
{{- end }}

    ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// New{{ .Spec.Model.EntityName }} returns a new *{{ .Spec.Model.EntityName }}
func New{{ .Spec.Model.EntityName }}() *{{ .Spec.Model.EntityName }} {

    return &{{ .Spec.Model.EntityName }}{
        ModelVersion: {{ .Set.APIInfo.Version }},

        {{- range $i, $attr := sortAttributes (.Spec.Attributes $latestVersion) -}}
        {{- if shouldWriteInitializer $.Spec $attr.Name $latestVersion $.PublicMode }}
        {{- $init := writeInitializer $.Set $.Spec $attr }}
        {{- if $init }}
        {{ $init }}
        {{- end }}
        {{- end }}
        {{- end }}
    }
}

{{- if not .Spec.Model.Detached }}
// Identity returns the Identity of the object.
func (o *{{ .Spec.Model.EntityName }}) Identity() elemental.Identity {

    return {{ .Spec.Model.EntityName }}Identity
}
{{- end }}

{{- if not .Spec.Model.Detached }}
// Identifier returns the value of the object's unique identifier.
func (o *{{ .Spec.Model.EntityName }}) Identifier() string {

    {{ if .Spec.Identifier -}}
    return o.{{ .Spec.Identifier.ConvertedName }}
    {{- else -}}
    return ""
    {{- end }}
}
{{- end }}

{{- if not .Spec.Model.Detached }}
// SetIdentifier sets the value of the object's unique identifier.
func (o *{{ .Spec.Model.EntityName }}) SetIdentifier(id string) {

    {{ if .Spec.Identifier -}}
    o.{{ .Spec.Identifier.ConvertedName }} = id
    {{- end }}
}
{{- end }}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *{{ .Spec.Model.EntityName }}) GetBSON() (interface{}, error) {

    if o == nil {
        return nil, nil
    }

    s := &mongoAttributes{{ .Spec.Model.EntityName }}{}
    {{ range .Spec.Attributes $latestVersion -}}
    {{- if .Stored }}
    {{- if .Identifier }}
    if o.{{ .ConvertedName }} != "" {
        s.{{ .ConvertedName }} = bson.ObjectIdHex(o.{{ .ConvertedName }})
    }
    {{- else }}
    s.{{ .ConvertedName }} = o.{{ .ConvertedName }}
    {{- end }}
    {{- end }}
    {{- end }}

    return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *{{ .Spec.Model.EntityName }}) SetBSON(raw bson.Raw) error {

    if o == nil {
        return nil
    }

    s := &mongoAttributes{{ .Spec.Model.EntityName }}{}
    if err := raw.Unmarshal(s); err != nil {
        return err
    }
    {{ range .Spec.Attributes $latestVersion -}}
    {{- if .Stored }}
    {{- if .Identifier }}
    o.{{ .ConvertedName }} = s.{{ .ConvertedName }}.Hex()
    {{- else }}
    o.{{ .ConvertedName }} = s.{{ .ConvertedName }}
    {{- end }}
    {{- end }}
    {{- end }}

    return nil
}

{{- if not .Spec.Model.Detached }}
// Version returns the hardcoded version of the model.
func (o *{{ .Spec.Model.EntityName }}) Version() int {

    return {{ .Set.APIInfo.Version }}
}
{{- end }}

// BleveType implements the bleve.Classifier Interface.
func (o *{{ .Spec.Model.EntityName }}) BleveType() string {

    return "{{ .Spec.Model.RestName }}"
}

{{- if not .Spec.Model.Detached }}
// DefaultOrder returns the list of default ordering fields.
func (o *{{ .Spec.Model.EntityName  }}) DefaultOrder() []string {

    return []string{
        {{ range .Spec.DefaultOrder -}}
        "{{ . }}",
        {{ end }}
    }
}
{{- end }}

{{- if not .Spec.Model.Detached }}
{{ if .Spec.Model.Description }}
// Doc returns the documentation for the object
func (o *{{ .Spec.Model.EntityName }}) Doc() string {

    return `{{ escBackticks .Spec.Model.Description }}`
}
{{ end }}
{{- end }}

{{- if not .Spec.Model.Detached }}
func (o *{{ .Spec.Model.EntityName }}) String() string {

    return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}
{{- end }}

{{ range .Spec.Attributes $latestVersion }}
{{ if shouldGenerateGetter . $.PublicMode }}
// Get{{ .ConvertedName }} returns the {{ .ConvertedName }} of the receiver.
func (o *{{ $.Spec.Model.EntityName }}) Get{{ .ConvertedName }}() {{ .ConvertedType }} {

    return o.{{ .ConvertedName }}
}

{{ end }}
{{ if shouldGenerateSetter . $.PublicMode }}
// Set{{ .ConvertedName }} sets the property {{ .ConvertedName }} of the receiver using the given value.
func (o *{{ $.Spec.Model.EntityName }}) Set{{ .ConvertedName }}({{ .Name }} {{ .ConvertedType }}) {

    o.{{ .ConvertedName }} = {{ .Name }}
}
{{ end }}
{{ end }}

{{- if and (not .Spec.Model.Detached) (not .Spec.Model.IsRoot) }}
// ToSparse returns the sparse version of the model.
// The returned object will only contain the given fields. No field means entire field set.
func (o *{{ .Spec.Model.EntityName }}) ToSparse(fields ...string) elemental.SparseIdentifiable {

    if len(fields) == 0 {
        // nolint: goimports
        return &Sparse{{ .Spec.Model.EntityName }} {
            {{- range .Spec.Attributes $latestVersion }}
            {{- if hasPrefix (attrToType $.Set false .) "*" }}
            {{ .ConvertedName }}: o.{{ .ConvertedName }},
            {{- else }}
            {{ .ConvertedName }}: &o.{{ .ConvertedName }},
            {{- end }}
            {{- end }}
        }
    }

    sp := &Sparse{{ .Spec.Model.EntityName }} {}
    for _, f := range fields {
        switch f {
            {{- range .Spec.Attributes $latestVersion }}
            case "{{ .Name }}":
                {{- if hasPrefix (attrToType $.Set false .) "*" }}
                sp.{{ .ConvertedName}} = o.{{ .ConvertedName }}
                {{- else }}
                sp.{{ .ConvertedName}} = &(o.{{ .ConvertedName }})
                {{- end }}
            {{- end }}
        }
    }

    return sp
}

{{- if $isEncryptable }}
// EncryptAttributes encrypts the attributes marked as `encrypted` using the given encrypter.
func (o *{{ .Spec.Model.EntityName }}) EncryptAttributes(encrypter elemental.AttributeEncrypter) (err error) {
    {{ range .Spec.Attributes $latestVersion }}
    {{- if .Encrypted }}
    if o.{{ .ConvertedName}}, err = encrypter.EncryptString(o.{{ .ConvertedName}}); err != nil {
        return fmt.Errorf("unable to encrypt attribute '{{ .ConvertedName}}' for '{{ $.Spec.Model.EntityName }}' (%s): %s", o.Identifier(), err)
    }
    {{- end }}
    {{- end }}

    return nil
}

// DecryptAttributes decrypts the attributes marked as `encrypted` using the given decrypter.
func (o *{{ .Spec.Model.EntityName }}) DecryptAttributes(encrypter elemental.AttributeEncrypter) (err error) {
    {{ range .Spec.Attributes $latestVersion }}
    {{- if .Encrypted }}
    if o.{{ .ConvertedName}}, err = encrypter.DecryptString(o.{{ .ConvertedName}}); err != nil {
        return fmt.Errorf("unable to decrypt attribute '{{ .ConvertedName}}' for '{{ $.Spec.Model.EntityName }}' (%s): %s", o.Identifier(), err)
    }
    {{- end }}
    {{- end }}

    return nil
}

{{- end }}


// Patch apply the non nil value of a *Sparse{{ .Spec.Model.EntityName }} to the object.
func (o *{{ .Spec.Model.EntityName }}) Patch(sparse elemental.SparseIdentifiable) {

    {{- $attrs := .Spec.Attributes $latestVersion }}
    {{- if $attrs }}
    if !sparse.Identity().IsEqual(o.Identity()) {
        panic("cannot patch from a parse with different identity")
    }

    so := sparse.(*Sparse{{ .Spec.Model.EntityName }})

    {{- range $attrs }}
    if so.{{ .ConvertedName }} != nil {
        {{- if hasPrefix (attrToType $.Set false .) "*" }}
        o.{{ .ConvertedName }} = so.{{ .ConvertedName }}
        {{- else }}
        o.{{ .ConvertedName }} = *so.{{ .ConvertedName }}
        {{- end }}
    }
   {{- end }}
   {{- end }}
}
{{- end }}

// DeepCopy returns a deep copy if the {{ .Spec.Model.EntityName }}.
func (o *{{ .Spec.Model.EntityName }}) DeepCopy() *{{ .Spec.Model.EntityName }} {

    if o == nil {
		return nil
	}

	out := &{{ .Spec.Model.EntityName }}{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *{{ .Spec.Model.EntityName }}.
func (o *{{ .Spec.Model.EntityName }}) DeepCopyInto(out *{{ .Spec.Model.EntityName }}) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy {{ .Spec.Model.EntityName }}: %s", err))
	}

	*out = *target.(*{{ .Spec.Model.EntityName }})
}

// Validate valides the current information stored into the structure.
func (o *{{ .Spec.Model.EntityName }}) Validate() error {

    errors := elemental.Errors{}
    requiredErrors := elemental.Errors{}

    {{ range .Spec.Attributes $latestVersion }}
    {{ if not .Transient }}
    {{ if .Exposed }}

    {{ if .Required }}
    {{ if eq .Type "string" }}
    if err := elemental.ValidateRequiredString("{{ .Name }}", o.{{ .ConvertedName }}); err != nil {
        requiredErrors = requiredErrors.Append(err)
    }
    {{ end }}

    {{ if or (eq .Type "enum") }}
    if err := elemental.ValidateRequiredString("{{ .Name }}", string(o.{{ .ConvertedName }})); err != nil {
        requiredErrors = requiredErrors.Append(err)
    }
    {{ end }}

    {{ if eq .Type "time" }}
    if err := elemental.ValidateRequiredTime("{{ .Name }}", o.{{ .ConvertedName }}); err != nil {
        requiredErrors = requiredErrors.Append(err)
    }
    {{ end }}

    {{ if or (eq .Type "external") (eq .Type "list")}}
    if err := elemental.ValidateRequiredExternal("{{ .Name }}", o.{{ .ConvertedName }}); err != nil {
        requiredErrors = requiredErrors.Append(err)
    }
    {{ end }}

    {{ if eq .Type "integer" }}
    if err := elemental.ValidateRequiredInt("{{ .Name }}", o.{{ .ConvertedName }}); err != nil {
        requiredErrors = requiredErrors.Append(err)
    }
    {{ end }}

    {{ if eq .Type "float" }}
    if err := elemental.ValidateRequiredFloat("{{ .Name }}", o.{{ .ConvertedName }}); err != nil {
        requiredErrors = requiredErrors.Append(err)
    }
    {{ end }}

    {{ end }}

    {{ if eq .Type "ref" }}
    if o.{{ .ConvertedName }} != nil {
        elemental.ResetDefaultForZeroValues(o.{{ .ConvertedName }})
        if err := o.{{ .ConvertedName }}.Validate(); err != nil {
            errors = errors.Append(err)
        }
    }
    {{ end }}

    {{ if or (eq .Type "refList") (eq .Type "refMap") }}
    for _, sub := range o.{{ .ConvertedName }} {
        if sub == nil {
            continue
        }
        elemental.ResetDefaultForZeroValues(sub)
        if err := sub.Validate(); err != nil {
            errors = errors.Append(err)
        }
    }
    {{ end }}

    {{ if .AllowedChoices }}
    if err := elemental.ValidateStringInList("{{ .Name }}", string(o.{{ .ConvertedName }}), []string{"{{ join .AllowedChoices `", "` }}"}, {{ .Autogenerated }}); err != nil {
        errors = errors.Append(err)
    }
    {{ end }}

    {{ if .AllowedChars }}
    if err := elemental.ValidatePattern("{{ .Name }}", o.{{ .ConvertedName }}, `{{ .AllowedChars }}`, `{{ .AllowedCharsMessage }}`, {{ .Required }}); err != nil {
        errors = errors.Append(err)
    }
    {{ end }}

    {{ if gt .MaxLength 0 }}
    if err := elemental.ValidateMaximumLength("{{ .Name }}", o.{{ .ConvertedName }}, {{ .MaxLength }}, false); err != nil {
        errors = errors.Append(err)
    }
    {{ end }}

    {{ if gt .MinLength 0 }}
    if err := elemental.ValidateMinimumLength("{{ .Name }}", o.{{ .ConvertedName }}, {{ .MinLength }}, false); err != nil {
        errors = errors.Append(err)
    }
    {{ end }}

    {{ if gt .MaxValue 0.0 }}
    {{ if eq .Type "float" }}
    if err := elemental.ValidateMaximumFloat("{{ .Name }}", o.{{ .ConvertedName }}, {{ .MaxValue }}, false); err != nil {
        errors = errors.Append(err)
    }
    {{ else }}

    if err := elemental.ValidateMaximumInt("{{ .Name }}", o.{{ .ConvertedName }}, int({{ .MaxValue }}), false); err != nil {
        errors = errors.Append(err)
    }
    {{ end }}
    {{ end }}

    {{ if gt .MinValue 0.0 }}
    {{ if eq .Type "float" }}
    if err := elemental.ValidateMinimumFloat("{{ .Name }}", o.{{ .ConvertedName }}, {{ .MinValue }}, false); err != nil {
        errors = errors.Append(err)
    }
    {{ else }}
    if err := elemental.ValidateMinimumInt("{{ .Name }}", o.{{ .ConvertedName }}, int({{ .MinValue }}), false); err != nil {
        errors = errors.Append(err)
    }
    {{ end }}
    {{ end }}

    {{ $attr := . }}
    {{- range $i, $m := .ValidationProviders }}
    if err := {{ $m.Name }}("{{ $attr.Name }}", o.{{ $attr.ConvertedName }}); err != nil {
        errors = errors.Append(err)
    }
    {{- end }}

    {{ end }}
    {{ end }}
    {{ end }}

    {{- range $i, $validationName := .Spec.Model.Validations }}
    // Custom object validation.
    {{- $mapping := $.Set.ValidationMapping.Mapping "elemental" $validationName }}
    {{- if $mapping }}
    if err := {{ $mapping.Name }}(o); err != nil {
        errors = errors.Append(err)
    }
    {{- end }}
    {{- end }}

    if len(requiredErrors) > 0 {
      return requiredErrors
    }

    if len(errors) > 0 {
        return errors
    }

    return nil
}

{{- if not .Spec.Model.Detached }}
// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (*{{ .Spec.Model.EntityName }}) SpecificationForAttribute(name string) elemental.AttributeSpecification {

    if v, ok := {{ .Spec.Model.EntityName }}AttributesMap[name]; ok {
        return v
    }

    // We could not find it, so let's check on the lower case indexed spec map
    return {{ .Spec.Model.EntityName }}LowerCaseAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (*{{ .Spec.Model.EntityName }}) AttributeSpecifications() map[string]elemental.AttributeSpecification {

    return {{ .Spec.Model.EntityName }}AttributesMap
}

// ValueForAttribute returns the value for the given attribute.
// This is a very advanced function that you should not need but in some
// very specific use cases.
func (o *{{ .Spec.Model.EntityName }}) ValueForAttribute(name string) interface{} {

    switch name {
    {{- range .Spec.Attributes $latestVersion }}
    case "{{ .Name }}":
        return o.{{ .ConvertedName }}
    {{- end }}
    }

    return nil
}

// {{ .Spec.Model.EntityName }}AttributesMap represents the map of attribute for {{ .Spec.Model.EntityName }}.
var {{ .Spec.Model.EntityName }}AttributesMap = map[string]elemental.AttributeSpecification{

    {{- range .Spec.Attributes $latestVersion }}
    {{ if shouldWriteAttributeMap . $.PublicMode -}}
    "{{ .ConvertedName }}": {
        {{- if .AllowedChars }}
        AllowedChars: `{{ .AllowedChars}}`,
        {{- end }}
        AllowedChoices: {{ if .AllowedChoices -}}[]string{"{{ join .AllowedChoices `", "` }}"}{{ else }}[]string{}{{ end }},
        {{- if .Autogenerated }}
        Autogenerated: {{ .Autogenerated }},
        {{- end }}
        {{- if .ConvertedName }}
        ConvertedName: "{{ .ConvertedName }}",
        {{- end }}
        {{- if .CreationOnly }}
        CreationOnly: {{ .CreationOnly }},
        {{- end }}
        {{- if .DefaultValue }}
        DefaultValue: {{ writeDefaultValue $.Set $.Spec . }},
        {{- end }}
        {{- if .Deprecated }}
        Deprecated: {{ .Deprecated }},
        {{- end }}
        {{- if .Description }}
        Description: `{{ escBackticks .Description }}`,
        {{- end }}
        {{- if .Encrypted }}
        Encrypted: {{ .Encrypted }},
        {{- end }}
        {{- if .Exposed }}
        Exposed: {{ .Exposed }},
        {{- end }}
        {{- if .Filterable }}
        Filterable: {{ .Filterable }},
        {{- end }}
        {{- if .ForeignKey }}
        ForeignKey: {{ .ForeignKey }},
        {{- end }}
        {{- if .Getter }}
        Getter: {{ .Getter }},
        {{- end }}
        {{- if .Identifier }}
        Identifier: {{ .Identifier }},
        {{- end }}
        {{- if .MaxLength }}
        MaxLength: {{ .MaxLength }},
        {{- end }}
        {{- if .MaxValue }}
        MaxValue: {{ .MaxValue }},
        {{- end }}
        {{- if .MinLength }}
        MinLength: {{ .MinLength }},
        {{- end }}
        {{- if .MinValue }}
        MinValue: {{ .MinValue }},
        {{- end }}
        {{- if .Name }}
        Name: "{{ .Name }}",
        {{- end }}
        {{- if .Orderable }}
        Orderable: {{ .Orderable }},
        {{- end }}
        {{- if .PrimaryKey }}
        PrimaryKey: {{ .PrimaryKey }},
        {{- end }}
        {{- if .ReadOnly }}
        ReadOnly: {{ .ReadOnly }},
        {{- end }}
        {{- if .Required }}
        Required: {{ .Required }},
        {{- end }}
        {{- if .Secret }}
        Secret: {{ .Secret }},
        {{- end }}
        {{- if .Setter }}
        Setter: {{ .Setter }},
        {{- end }}
        {{- if .Signed }}
        Signed: {{ .Signed }},
        {{- end }}
        {{- if .Stored }}
        Stored: {{ .Stored }},
        {{- end }}
        {{- if .SubType }}
        SubType: "{{ .SubType }}",
        {{- end }}
        {{- if .Transient }}
        Transient: {{ .Transient }},
        {{- end }}
        {{- if .Type }}
        Type: "{{ .Type }}",
        {{- end }}
    },
    {{- end }}
    {{- end }}
}

// {{ .Spec.Model.EntityName }}LowerCaseAttributesMap represents the map of attribute for {{ .Spec.Model.EntityName }}.
var {{ .Spec.Model.EntityName }}LowerCaseAttributesMap = map[string]elemental.AttributeSpecification{

    {{- range .Spec.Attributes $latestVersion }}
    {{ if shouldWriteAttributeMap . $.PublicMode -}}
    "{{ lower .Name }}": {
        {{- if .AllowedChars }}
        AllowedChars: `{{ .AllowedChars}}`,
        {{- end }}
        AllowedChoices: {{ if .AllowedChoices -}}[]string{"{{ join .AllowedChoices `", "` }}"}{{ else }}[]string{}{{ end }},
        {{- if .Autogenerated }}
        Autogenerated: {{ .Autogenerated }},
        {{- end }}
        {{- if .Stored }}
        BSONFieldName: "{{ attrBSONFieldName . }}",
        {{- end }}
        {{- if .ConvertedName }}
        ConvertedName: "{{ .ConvertedName }}",
        {{- end }}
        {{- if .CreationOnly }}
        CreationOnly: {{ .CreationOnly }},
        {{- end }}
        {{- if .DefaultValue }}
        DefaultValue: {{ writeDefaultValue $.Set $.Spec . }},
        {{- end }}
        {{- if .Deprecated }}
        Deprecated: {{ .Deprecated }},
        {{- end }}
        {{- if .Description }}
        Description: `{{ escBackticks .Description }}`,
        {{- end }}
        {{- if .Encrypted }}
        Encrypted: {{ .Encrypted }},
        {{- end }}
        {{- if .Exposed }}
        Exposed: {{ .Exposed }},
        {{- end }}
        {{- if .Filterable }}
        Filterable: {{ .Filterable }},
        {{- end }}
        {{- if .ForeignKey }}
        ForeignKey: {{ .ForeignKey }},
        {{- end }}
        {{- if .Getter }}
        Getter: {{ .Getter }},
        {{- end }}
        {{- if .Identifier }}
        Identifier: {{ .Identifier }},
        {{- end }}
        {{- if .MaxLength }}
        MaxLength: {{ .MaxLength }},
        {{- end }}
        {{- if .MaxValue }}
        MaxValue: {{ .MaxValue }},
        {{- end }}
        {{- if .MinLength }}
        MinLength: {{ .MinLength }},
        {{- end }}
        {{- if .MinValue }}
        MinValue: {{ .MinValue }},
        {{- end }}
        {{- if .Name }}
        Name: "{{ .Name }}",
        {{- end }}
        {{- if .Orderable }}
        Orderable: {{ .Orderable }},
        {{- end }}
        {{- if .PrimaryKey }}
        PrimaryKey: {{ .PrimaryKey }},
        {{- end }}
        {{- if .ReadOnly }}
        ReadOnly: {{ .ReadOnly }},
        {{- end }}
        {{- if .Required }}
        Required: {{ .Required }},
        {{- end }}
        {{- if .Secret }}
        Secret: {{ .Secret }},
        {{- end }}
        {{- if .Setter }}
        Setter: {{ .Setter }},
        {{- end }}
        {{- if .Signed }}
        Signed: {{ .Signed }},
        {{- end }}
        {{- if .Stored }}
        Stored: {{ .Stored }},
        {{- end }}
        {{- if .SubType }}
        SubType: "{{ .SubType }}",
        {{- end }}
        {{- if .Transient }}
        Transient: {{ .Transient }},
        {{- end }}
        {{- if .Type }}
        Type: "{{ .Type }}",
        {{- end }}
    },
    {{- end }}
    {{- end }}
}
{{- end }}

{{- if and (not .Spec.Model.Detached) (not .Spec.Model.IsRoot) }}

// Sparse{{ .Spec.Model.EntityNamePlural }}List represents a list of Sparse{{ .Spec.Model.EntityNamePlural }}
type Sparse{{ .Spec.Model.EntityNamePlural }}List []*Sparse{{ .Spec.Model.EntityName}}

// Identity returns the identity of the objects in the list.
func (o Sparse{{ .Spec.Model.EntityNamePlural }}List) Identity() elemental.Identity {

    return {{ .Spec.Model.EntityName}}Identity
}

// Copy returns a pointer to a copy the Sparse{{ .Spec.Model.EntityNamePlural }}List.
func (o Sparse{{ .Spec.Model.EntityNamePlural }}List) Copy() elemental.Identifiables {

    copy := append(Sparse{{ .Spec.Model.EntityNamePlural }}List{}, o...)
    return &copy
}

// Append appends the objects to the a new copy of the Sparse{{ .Spec.Model.EntityNamePlural }}List.
func (o Sparse{{ .Spec.Model.EntityNamePlural }}List) Append(objects ...elemental.Identifiable) elemental.Identifiables {

    out := append(Sparse{{ .Spec.Model.EntityNamePlural }}List{}, o...)
    for _, obj := range objects {
        out = append(out, obj.(*Sparse{{ .Spec.Model.EntityName}}))
    }

    return out
}

// List converts the object to an elemental.IdentifiablesList.
func (o Sparse{{ .Spec.Model.EntityNamePlural }}List) List() elemental.IdentifiablesList {

    out := make(elemental.IdentifiablesList, len(o))
    for i := 0; i < len(o); i++ {
        out[i] = o[i]
    }

    return out
}

// DefaultOrder returns the default ordering fields of the content.
func (o Sparse{{ .Spec.Model.EntityNamePlural }}List) DefaultOrder() []string {

    return []string{
        {{ range .Spec.DefaultOrder -}}
        "{{ . }}",
        {{ end }}
    }
}

// ToPlain returns the Sparse{{ .Spec.Model.EntityNamePlural }}List converted to {{ .Spec.Model.EntityNamePlural }}List.
func (o Sparse{{ .Spec.Model.EntityNamePlural }}List) ToPlain() elemental.IdentifiablesList {

    out := make(elemental.IdentifiablesList, len(o))
    for i := 0; i < len(o); i++ {
        out[i] = o[i].ToPlain()
    }

    return out
}

// Version returns the version of the content.
func (o Sparse{{ .Spec.Model.EntityNamePlural }}List) Version() int {

    return {{ .Set.APIInfo.Version }}
}

// Sparse{{ .Spec.Model.EntityName }} represents the sparse version of a {{ .Spec.Model.RestName }}.
type Sparse{{ .Spec.Model.EntityName }} struct {
    {{ range .Spec.Attributes $latestVersion -}}
    {{ attrToField $.Set true . }}
    {{- end }}

    ModelVersion int `json:"-" msgpack:"-" bson:"_modelversion"`
}

// NewSparse{{ .Spec.Model.EntityName }} returns a new  Sparse{{ .Spec.Model.EntityName }}.
func NewSparse{{ .Spec.Model.EntityName }}() *Sparse{{ .Spec.Model.EntityName }} {
    return &Sparse{{ .Spec.Model.EntityName }}{}
}

// Identity returns the Identity of the sparse object.
func (o *Sparse{{ .Spec.Model.EntityName }}) Identity() elemental.Identity {

    return {{ .Spec.Model.EntityName }}Identity
}

// Identifier returns the value of the sparse object's unique identifier.
func (o *Sparse{{ .Spec.Model.EntityName }}) Identifier() string {

    {{ if .Spec.Identifier -}}
    if o.{{ .Spec.Identifier.ConvertedName }} == nil {
        return ""
    }
    return *o.{{ .Spec.Identifier.ConvertedName }}
    {{- else -}}
    return ""
    {{- end }}
}

// SetIdentifier sets the value of the sparse object's unique identifier.
func (o *Sparse{{ .Spec.Model.EntityName }}) SetIdentifier(id string) {

    {{ if .Spec.Identifier -}}
    if id != "" {
        o.{{ .Spec.Identifier.ConvertedName }} = &id
    } else {
        o.{{ .Spec.Identifier.ConvertedName }} = nil
    }
    {{- end }}
}

// GetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *Sparse{{ .Spec.Model.EntityName }}) GetBSON() (interface{}, error) {

    if o == nil {
        return nil, nil
    }

    s := &mongoAttributesSparse{{ .Spec.Model.EntityName }}{}
    {{ range .Spec.Attributes $latestVersion -}}
    {{- if .Stored }}
    {{- if .Identifier }}
    if o.{{ .ConvertedName }} != nil {
        s.{{ .ConvertedName }} = bson.ObjectIdHex(*o.{{ .ConvertedName }})
    }
    {{- else }}
    if o.{{ .ConvertedName}} != nil {
    s.{{ .ConvertedName }} = o.{{ .ConvertedName }}
    }
    {{- end }}
    {{- end }}
    {{- end }}

    return s, nil
}

// SetBSON implements the bson marshaling interface.
// This is used to transparently convert ID to MongoDBID as ObectID.
func (o *Sparse{{ .Spec.Model.EntityName }}) SetBSON(raw bson.Raw) error {

    if o == nil {
        return nil
    }

    s := &mongoAttributesSparse{{ .Spec.Model.EntityName }}{}
    if err := raw.Unmarshal(s); err != nil {
        return err
    }
    {{ range .Spec.Attributes $latestVersion -}}
    {{- if .Stored }}
    {{- if .Identifier }}
    id := s.{{ .ConvertedName }}.Hex()
    o.{{ .ConvertedName }} = &id
    {{- else }}
    if s.{{ .ConvertedName}} != nil {
    o.{{ .ConvertedName }} = s.{{ .ConvertedName }}
    }
    {{- end }}
    {{- end }}
    {{- end }}

    return nil
}

// Version returns the hardcoded version of the model.
func (o *Sparse{{ .Spec.Model.EntityName }}) Version() int {

    return {{ .Set.APIInfo.Version }}
}

// ToPlain returns the plain version of the sparse model.
func (o *Sparse{{ .Spec.Model.EntityName }}) ToPlain() elemental.PlainIdentifiable {

    out := New{{ .Spec.Model.EntityName }}()
    {{- range .Spec.Attributes $latestVersion }}
    if o.{{ .ConvertedName}} != nil  {
        {{- if hasPrefix (attrToType $.Set false .) "*" }}
        out.{{ .ConvertedName }} = o.{{ .ConvertedName }}
        {{- else }}
        out.{{ .ConvertedName }} = *o.{{ .ConvertedName }}
        {{- end }}
    }
    {{- end }}

    return out
}

{{- if $isEncryptable }}
// EncryptAttributes encrypts the attributes marked as `encrypted` using the given encrypter.
func (o *Sparse{{ .Spec.Model.EntityName }}) EncryptAttributes(encrypter elemental.AttributeEncrypter) (err error) {
    {{ range .Spec.Attributes $latestVersion }}
    {{- if .Encrypted }}
    if *o.{{ .ConvertedName}}, err = encrypter.EncryptString(*o.{{ .ConvertedName}}); err != nil {
        return fmt.Errorf("unable to encrypt attribute '{{ .ConvertedName}}' for 'Sparse{{ $.Spec.Model.EntityName }}' (%s): %s", o.Identifier(), err)
    }
    {{- end }}
    {{- end }}

    return nil
}

// DecryptAttributes decrypts the attributes marked as `encrypted` using the given decrypter.
func (o *Sparse{{ .Spec.Model.EntityName }}) DecryptAttributes(encrypter elemental.AttributeEncrypter) (err error) {
    {{ range .Spec.Attributes $latestVersion }}
    {{- if .Encrypted }}
    if *o.{{ .ConvertedName}}, err = encrypter.DecryptString(*o.{{ .ConvertedName}}); err != nil {
        return fmt.Errorf("unable to decrypt attribute '{{ .ConvertedName}}' for 'Sparse{{ $.Spec.Model.EntityName }}' (%s): %s", o.Identifier(), err)
    }
    {{- end }}
    {{- end }}

    return nil
}
{{- end }}

{{ range .Spec.Attributes $latestVersion }}
{{ if shouldGenerateGetter . $.PublicMode }}
// Get{{ .ConvertedName }} returns the {{ .ConvertedName }} of the receiver.
func (o *Sparse{{ $.Spec.Model.EntityName }}) Get{{ .ConvertedName }}() (out {{ .ConvertedType }}) {

    if o.{{ .ConvertedName }} == nil {
        return
    }

    return *o.{{ .ConvertedName }}
}

{{ end }}
{{ if shouldGenerateSetter . $.PublicMode }}
// Set{{ .ConvertedName }} sets the property {{ .ConvertedName }} of the receiver using the address of the given value.
func (o *Sparse{{ $.Spec.Model.EntityName }}) Set{{ .ConvertedName }}({{ .Name }} {{ .ConvertedType }}) {

    o.{{ .ConvertedName }} = &{{ .Name }}
}
{{ end }}
{{ end }}

// DeepCopy returns a deep copy if the Sparse{{ .Spec.Model.EntityName }}.
func (o *Sparse{{ .Spec.Model.EntityName }}) DeepCopy() *Sparse{{ .Spec.Model.EntityName }} {

    if o == nil {
		return nil
	}

	out := &Sparse{{ .Spec.Model.EntityName }}{}
	o.DeepCopyInto(out)

	return out
}

// DeepCopyInto copies the receiver into the given *Sparse{{ .Spec.Model.EntityName }}.
func (o *Sparse{{ .Spec.Model.EntityName }}) DeepCopyInto(out *Sparse{{ .Spec.Model.EntityName }}) {

	target, err := copystructure.Copy(o)
	if err != nil {
		panic(fmt.Sprintf("Unable to deepcopy Sparse{{ .Spec.Model.EntityName }}: %s", err))
	}

	*out = *target.(*Sparse{{ .Spec.Model.EntityName }})
}
{{ end }}

type mongoAttributes{{ .Spec.Model.EntityName }} struct {
    {{- range .Spec.Attributes $latestVersion -}}
    {{- if .Stored }}
    {{ attrToMongoField $.Set false . }}
    {{- end }}
    {{- end }}
}

{{- if and (not .Spec.Model.Detached) (not .Spec.Model.IsRoot) }}
type mongoAttributesSparse{{ .Spec.Model.EntityName }} struct {
    {{- range .Spec.Attributes $latestVersion -}}
    {{- if .Stored }}
    {{ attrToMongoField $.Set true . }}
    {{- end }}
    {{- end }}
}
{{- end }}
